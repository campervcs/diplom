package com.igumnov.common.orm;


import com.igumnov.common.Log;
import com.igumnov.common.Reflection;
import com.igumnov.common.orm.annotations.Id;
import com.igumnov.common.reflection.ReflectionAPI;
import com.igumnov.common.reflection.ReflectionException;

import java.io.IOException;
import java.io.Reader;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

public class Transaction {
    private Connection connection;
    private Class idClass = null;

    public Transaction(Connection c, Class id) throws SQLException {
        idClass = id;
        connection = c;
        c.setAutoCommit(false);
    }

    public void commit() throws SQLException {
        try {
            connection.commit();
        } finally {
            try {
                connection.setAutoCommit(false);
            } finally {
                connection.close();
            }
        }
    }

    public void rollback() throws SQLException {
        try {
            connection.rollback();
        } finally {
            try {
                connection.setAutoCommit(false);
            } finally {
                connection.close();
            }
        }
    }

    public Object update(Object obj) throws IllegalAccessException, SQLException {
        Map<String, Object> fields = new LinkedHashMap<>();
        String pkField = null;
        Object pkFieldValue = null;
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (!java.lang.reflect.Modifier.isStatic(field.getModifiers())) {
                if (field.isAnnotationPresent(Id.class)) {
                    pkField = field.getAnnotation(Id.class).fieldName();
                    field.setAccessible(true);
                    pkFieldValue = field.get(obj);
                } else if (field.isAnnotationPresent(com.igumnov.common.orm.annotations.Field.class)) {
                    field.setAccessible(true);
                    fields.put(field.getAnnotation(com.igumnov.common.orm.annotations.Field.class).fieldName(), field.get(obj));
                }

            }
        }

        Set<String> fieldsSet = fields.keySet();
        String names = fieldsSet.stream().collect(Collectors.joining("=?,", "", "=?"));

        String tableName = "";
        for (Table t : ReflectionAPI.getTables()) {
            if (t.getEntity().getTypeName().equals(obj.getClass().getTypeName()))
                tableName = t.getTableName();
        }
        Log.info(tableName);
        String sql = "update  " + tableName + " set " + names + " where " + pkField + "=?";
        Log.info(sql);

        PreparedStatement preparedStatement = null;
        try {
            preparedStatement = connection.prepareStatement(sql);


            Iterator<String> it = fieldsSet.iterator();
            int i = 1;
            while (it.hasNext()) {
                Object value = fields.get(it.next());
                preparedStatement.setObject(i, value);
                ++i;
            }
            preparedStatement.setObject(i, pkFieldValue);
            Log.debug(sql);
            preparedStatement.executeUpdate();


        } finally {
            try {
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
            } catch (Exception e) {
                /* ignore */
            }
        }
        return obj;


    }

    public Object insert(Object obj) throws IllegalAccessException, SQLException, ReflectionException, NoSuchMethodException, InvocationTargetException {

        LinkedHashMap<String, Object> fields = new LinkedHashMap<>();
        boolean autoGenerated = false;
        String autoGeneratedField = null;
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(Id.class)) {
                Boolean autoIncremental;
                if (Reflection.getFieldValue(obj, field.getName()) == null) {
                    autoIncremental = field.getAnnotation(Id.class).autoIncremental();
                } else {
                    autoIncremental = false;
                }
                if (autoIncremental) {
                    autoGenerated = true;
                    autoGeneratedField = field.getName();
                } else
                    fields.put(field.getAnnotation(Id.class).fieldName(), field.get(obj));
            }

            if (field.isAnnotationPresent(com.igumnov.common.orm.annotations.Field.class)) {
                field.setAccessible(true);
                fields.put(field.getAnnotation(com.igumnov.common.orm.annotations.Field.class).fieldName(), field.get(obj));
            }
        }

        Set<String> fieldsSet = fields.keySet();
        String names = fieldsSet.stream().collect(Collectors.joining(","));
        String values = fieldsSet.stream().map(it -> "?").collect(Collectors.joining(","));

        String tableName = "";
        for (Table t : ReflectionAPI.getTables()) {
            if (t.getEntity().getTypeName().equals(obj.getClass().getTypeName()))
                tableName = t.getTableName();
            Log.info(t.getEntity().getTypeName()+ " compare with "+obj.getClass().getSimpleName() + "   150th");
        }
        String sql = "insert into " + tableName + "(" + names + ") values (" + values + ")";
        Log.info(sql);
        PreparedStatement preparedStatement = null;
        try {
            if (!autoGenerated) {
                preparedStatement = connection.prepareStatement(sql);
            } else {
                preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            }

            Iterator<String> it = fieldsSet.iterator();
            int i = 1;
            while (it.hasNext()) {
                preparedStatement.setObject(i, fields.get(it.next()));
                ++i;
            }
            Log.debug(sql);
            preparedStatement.executeUpdate();

            if (autoGenerated) {
                ResultSet tableKeys = preparedStatement.getGeneratedKeys();
                tableKeys.next();
                Object autoGeneratedID = tableKeys.getObject(1);
                Reflection.setField(obj, autoGeneratedField, autoGeneratedID);
            }
        } finally {
            try {
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
            } catch (Exception e) {
                /* ignore */
            }
        }
        return obj;
    }

    public ArrayList<Object> findBy(String where, Class classObject, Object... params) throws SQLException, IllegalAccessException, InstantiationException, ReflectionException, IOException {
        ArrayList<Object> ret = new ArrayList<>();
        String names = "";
        Table t = null;
        for (Table table : ReflectionAPI.getTables()){
            if (table.getEntity().getTypeName().equals(classObject.getSimpleName()))
                Log.info(table.getEntity().getTypeName()+"  "+classObject.getSimpleName());
                t=table;
        }
        for (SimpleField field : t.getFields()) {
                if (names.length() > 0) {
                    names = names + ",";
                }
                names = names + field.getDbName();

        }


        String sql;
        if (where == null) {
            sql = "select " + names + " from  " + t.getTableName();
        } else {
            sql = "select " + names + " from  " + t.getTableName() + " where " + where;
        }
        System.out.println(sql);
        PreparedStatement preparedStatement = null;
        try {
            preparedStatement = connection.prepareStatement(sql);
            int i = 1;
            for (Object param : params) {
                preparedStatement.setObject(i, param);
                ++i;
            }
            Log.debug(sql);
            ResultSet r = preparedStatement.executeQuery();
            while (r.next()) {
                Object row = classObject.newInstance();
                for (SimpleField field : t.getFields()) {
                        Object value = r.getObject(field.getDbName());
                        if (value instanceof java.sql.Clob) {

                            Reader reader = ((Clob) value).getCharacterStream();

                            int intValueOfChar;
                            String targetString = "";
                            while ((intValueOfChar = reader.read()) != -1) {
                                targetString += (char) intValueOfChar;
                            }
                            reader.close();

                            Reflection.setField(row, field.getJavaName(), targetString);
                        } else {
                            Reflection.setField(row, field.getJavaName(), value);
                        }
                }
                ret.add(row);
            }

            r.close();

        } finally {
            try {
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
            } catch (Exception e) {
                /* ignore */
            }

        }

        return ret;
    }

    public Object findOne(Class className, Object primaryKey) throws SQLException, ReflectionException, InstantiationException, IllegalAccessException, IOException {
        String pkName = null;
        Table t = null;
        for (Table table : ReflectionAPI.getTables()){
            if (table.getEntity().getTypeName().equals(className.getTypeName()))
                t=table;
        }
        for (Field field : className.getDeclaredFields()) {
                    for (Annotation annotation : field.getDeclaredAnnotations())
                        if (annotation.annotationType().equals(idClass)) {
                    pkName = t.getMapping().get(field.getName());
                    if (field.getType().getName().equals("java.lang.Long") && primaryKey instanceof String) {
                        ArrayList<Object> ret = findBy(pkName + "=?", className, Long.valueOf((String) primaryKey));
                        if (ret.size() > 0) {
                            return ret.get(0);
                        } else {
                            return null;
                        }
                    }
                    if (field.getType().getName().equals("java.lang.Double") && primaryKey instanceof String) {
                        ArrayList<Object> ret = findBy(pkName + "=?", className, Double.valueOf((String) primaryKey));
                        if (ret.size() > 0) {
                            return ret.get(0);
                        } else {
                            return null;
                        }
                    }
                    if (field.getType().getName().equals("java.lang.Float") && primaryKey instanceof String) {
                        ArrayList<Object> ret = findBy(pkName + "=?", className, Float.valueOf((String) primaryKey));
                        if (ret.size() > 0) {
                            return ret.get(0);
                        } else {
                            return null;
                        }
                    }
                    if (field.getType().getName().equals("java.lang.Integer") && primaryKey instanceof String) {
                        ArrayList<Object> ret = findBy(pkName + "=?", className, Integer.valueOf((String) primaryKey));
                        if (ret.size() > 0) {
                            return ret.get(0);
                        } else {
                            return null;
                        }
                    }


                    ArrayList<Object> ret = findBy(pkName + "=?", className, primaryKey);
                    if (ret.size() > 0) {
                        return ret.get(0);
                    } else {
                        return null;
                    }

                }
        }
        throw new ReflectionException("Cant find PK attribute");
    }

    public int deleteBy(String where, Class classObject, Object... params) throws SQLException {

        Table t=null;
        for (Table table : ReflectionAPI.getTables()){
            if (table.getEntity().getTypeName().equals(classObject.getTypeName()))
                t=table;
        }
        String sql = "delete from " + t.getTableName() + " where " + where;

       Log.info(sql);

        PreparedStatement preparedStatement = null;
        try {
            preparedStatement = connection.prepareStatement(sql);


            int i = 1;
            for (Object param : params) {
                preparedStatement.setObject(i, param);
                ++i;
            }

            Log.debug(sql);
            return preparedStatement.executeUpdate();


        } finally {
            try {
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
            } catch (Exception e) {
                /* ignore */
            }
        }


    }

    public int delete(Object obj) throws IllegalAccessException, SQLException {

        String pkName = null;
        Object pkValue = null;
        for (Field field : obj.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(Id.class)) {
                pkName = field.getAnnotation(Id.class).fieldName();
                field.setAccessible(true);
                pkValue = field.get(obj);
            }
        }
        return deleteBy(pkName + "=?", obj.getClass(), pkValue);
    }

    public ArrayList<Object> findAll(Class classObject) throws SQLException, ReflectionException, InstantiationException, IllegalAccessException, IOException {
        return findBy(null, classObject);
    }

    public ArrayList<HashMap<String, Object>> selectQuery(String sqlQuery, Object... params) throws SQLException {

        PreparedStatement preparedStatement = null;
        try {
            ArrayList<HashMap<String, Object>> ret = new ArrayList<HashMap<String, Object>>();
            preparedStatement = connection.prepareStatement(sqlQuery);
            int i = 1;
            for (Object param : params) {
                preparedStatement.setObject(i, param);
                ++i;
            }
            Log.debug(sqlQuery);
            ResultSet r = preparedStatement.executeQuery();
            ResultSetMetaData rsmd = r.getMetaData();
            while (r.next()) {
                HashMap<String, Object> row = new HashMap<String, Object>();
                for (i = 1; i <= rsmd.getColumnCount(); ++i) {
                    String name = rsmd.getColumnName(i);
                    Object value = r.getObject(name);
                    row.put(name, value);
                }
                ret.add(row);
            }
            return ret;

        } finally {
            if (preparedStatement != null) {
                preparedStatement.close();
            }
        }
    }

    public void GenerateTables(List<Table> entities) throws SQLException {
        Statement preparedStatement = null;
        try {
            preparedStatement = connection.createStatement();
            for (Table table : entities) {
                StringBuilder sql = new StringBuilder("CREATE TABLE IF NOT EXISTS `");
                sql.append(table.getTableName() + "` (\n");
                for (SimpleField field : table.getFields()) {
                    if (field.isPK()) {
                        sql.append("`" + field.getDbName() + "` " + ConvertType(field.getType()));
                        if (field.isAutoincrement()) sql.append(" AUTO_INCREMENT");
                        sql.append(",\n");
                        sql.append("PRIMARY KEY (`" + field.getDbName() + "`)");
                        sql.append(",");
                        sql.append("\n");
                    } else {
                        sql.append("`" + field.getDbName() + "` " + ConvertType(field.getType()));
                        if (field.isAutoincrement()) sql.append(" AUTO_INCREMENT");
                        sql.append(",\n");
                    }
                }
                sql.deleteCharAt(sql.lastIndexOf(","));
                sql.append(")");
                preparedStatement.addBatch(sql.toString());
                Log.info(sql.toString());
            }
            preparedStatement.executeBatch();
        } finally {
            try {
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
            } catch (Exception e) {
                /* ignore */
            }
        }
    }

    private String ConvertType(Type type) {
        String DatabaseType = "";
        switch (type.toString()) {
            case "class java.lang.String":
                DatabaseType = "varchar(255)";
                break;
            case "class java.math.BigDecimal":
                DatabaseType = "decimal(65)";
                break;
            case "class java.lang.Long":
                DatabaseType = "BIGINT(255)";
                break;
            case "class java.lang.Short":
                DatabaseType = "SMALLINT(255)";
                break;
            case "class java.lang.Float":
                DatabaseType = "FLOAT";
                break;
            case "class java.util.Date":
                DatabaseType = "DATETIME";
                break;
            case "class java.sql.Date":
                DatabaseType = "DATETIME";
                break;
            case "class java.lang.Boolean":
                DatabaseType = "BINARY(1)";
                break;
            case "class java.lang.Integer":
                DatabaseType = "INT";
                break;
            case "class java.sql.Time":
                DatabaseType = "TIME(6)";
                break;
            case "long":
                DatabaseType = "BIGINT(255)";
                break;
            case "short":
                DatabaseType = "SMALLINT(255)";
                break;
            case "float":
                DatabaseType = "FLOAT";
                break;
            case "boolean":
                DatabaseType = "BINARY(1)";
                break;
            case "int":
                DatabaseType = "INT";
                break;
            default:
                DatabaseType = "varchar(255)";
                break;
        }
        return DatabaseType;
    }
}